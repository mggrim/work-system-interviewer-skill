# SupportRouter - Email to Ticket Automation System

## Overview

- **Purpose**: Automatically convert customer support emails into tickets, categorize by product area, and route to appropriate team members
- **Last Updated**: 2026-01-13
- **Status**: Ready for Implementation

## System Scope

### In Scope

- Parse incoming emails to support@company.com
- Extract customer info, issue description, attachments
- AI-powered categorization by product area
- Automatic priority assignment based on keywords and customer tier
- Smart routing to team members based on expertise and workload
- Create tickets in Linear (our project management tool)
- Send confirmation emails to customers
- Handle customer replies (update existing tickets)

### Explicitly Out of Scope (Non-Goals)

- NOT replacing Linear for ticket management (this creates tickets there, doesn't replace it)
- NOT handling phone support (email only)
- NOT providing customer-facing status page (use separate tool for that)
- NOT doing sentiment analysis or customer satisfaction scoring (CSAT handled separately)
- NOT archiving original emails (rely on email provider's archive)

## User Profiles

### Primary Users

- **Support Team** (5-7 people): Receive tickets in Linear, work them to completion. Not directly interacting with this automation system (just see the results).
- **Customers** (1000s): Send emails to support@company.com, receive automated confirmation, get resolution via email. No login or account needed.
- **Support Manager** (1 person): Monitors automation performance, adjusts routing rules, reviews misclassified tickets. Weekly interaction.

### Technical Level

**Customers**: Non-technical. Just send email, expect reply.

**Support Team**: Intermediate. Comfortable with Linear, email, basic troubleshooting.

**Manager**: Advanced. Comfortable with JSON config files, reviewing logs, adjusting automation rules.

## Work Flow

### Input & Capture

#### Entry Points

- **Email**: support@company.com forwarded to AWS SES → trigger Lambda function → parse and process
- **Manual Override**: Support manager can manually create ticket via Linear API (bypass automation)

#### Required Metadata

Extracted from email:
- **Customer Email** (required, from email headers): Requester identity
- **Customer Name** (optional, from email "From" field): For personalization
- **Subject** (required, email subject): Becomes ticket title
- **Body** (required, email body): Issue description
- **Attachments** (optional, email attachments): Screenshots, logs, etc.
- **Received At** (required, timestamp): When email received
- **Customer Tier** (required, looked up from CRM): Free/Pro/Enterprise (affects priority)

Generated by system:
- **Product Area** (required, AI-categorized): Which product component
- **Priority** (required, auto-calculated): P0-P3 based on keywords + tier
- **Assigned To** (required, auto-routed): Team member ID
- **Linear Ticket ID** (required, after creation): Reference to ticket in Linear

#### Work Types

All emails treated as "support requests" but categorized by product area:
- **Mobile App**: Issues with iOS or Android app
- **Web App**: Issues with browser-based application
- **API**: Developer questions or API errors
- **Billing**: Payment, subscription, invoice questions
- **Account**: Login, password, access issues

Type detected via AI analysis of email content and subject.

### Processing & Organization

#### Categorization Logic

- **AI Classification**: Claude API analyzes subject + body, returns product area with confidence score
- **High Confidence** (>85%): Auto-assign product area
- **Medium Confidence** (60-85%): Assign but flag for review (add `needs-review` tag in Linear)
- **Low Confidence** (<60%): Default to "General" category, assign to manager for manual categorization

#### Priority Framework

Priority calculated using combination of factors:

**P0 (Critical)**: Enterprise customer + keywords ("down", "outage", "all users")
**P1 (High)**: Pro/Enterprise customer + keywords ("broken", "error", "can't access")
**P2 (Normal)**: Any customer with standard issue
**P3 (Low)**: Free tier + keywords ("feature request", "suggestion", "when will")

Logic:
```
if customer_tier == "Enterprise" AND critical_keywords_found:
    priority = "P0"
elif customer_tier in ["Pro", "Enterprise"] AND error_keywords_found:
    priority = "P1"
elif feature_request_keywords_found:
    priority = "P3"
else:
    priority = "P2"  # default
```

#### Workflow States

This system creates tickets. Linear handles state transitions. States in Linear:
1. **Triage**: New ticket, needs initial review
2. **Todo**: Confirmed, in queue
3. **In Progress**: Team member working on it
4. **Done**: Resolved

Automation creates tickets in "Triage" state. Support team manually transitions through states in Linear.

#### Automation Rules

**1. Email Parsing**
- Trigger: Email received at support@company.com
- Action: AWS SES → SNS → Lambda → Parse email (extract metadata)

**2. Customer Lookup**
- Action: Query CRM API with customer email → Get tier (Free/Pro/Enterprise)
- Fallback: If not found in CRM, assume "Free" tier

**3. AI Categorization**
- Action: Call Claude API with subject + first 1000 chars of body → Get product area + confidence
- Caching: Cache categorization for identical subjects (reduce API costs)

**4. Priority Calculation**
- Action: Apply priority logic (tier + keywords) → Assign P0-P3

**5. Smart Routing**
- Action: Look up team members assigned to product area → Filter by availability → Choose member with fewest open tickets
- Fallback: If no specialists available, assign to manager

**6. Ticket Creation**
- Action: Call Linear API → Create ticket with all metadata
- Attachments: Upload to S3, include links in ticket description

**7. Customer Confirmation**
- Action: Send email via SendGrid: "We received your request. Ticket #123. We'll respond within [SLA based on priority]."

**8. Reply Handling**
- Trigger: Customer replies to confirmation email
- Action: Parse email, extract Linear ticket ID from subject, add comment to existing ticket via Linear API

### Output & Interaction

#### User Interface

**Customers**: Email-only interaction. No UI.
- Send email → Receive auto-confirmation → Receive resolution email (manually sent by support team from Linear)

**Support Team**: Linear UI (existing tool)
- View tickets in "Triage" queue
- See all metadata (customer, product area, priority, original email content)
- Work tickets, add comments, change status

**Manager**: Linear + Config Dashboard (admin web app)
- **Linear**: See all tickets, including misclassified ones
- **Dashboard**: View automation metrics, adjust routing rules (JSON config), review classification accuracy

#### Key Actions

**For System (Automated)**:
- Parse email → Extract metadata
- Categorize → AI determines product area
- Route → Assign to team member
- Create ticket → Post to Linear API
- Send confirmation → Email customer

**For Manager (Manual)**:
- Adjust routing rules (edit JSON config file)
- Review misclassified tickets (filter by `needs-review` tag)
- Recategorize ticket (manually change product area in Linear)

#### Notifications/Alerts

- **Customer Confirmation**: Immediate email after ticket created. Includes ticket ID and expected response time.
- **Team Assignment**: Linear's built-in notification (Slack or email) when ticket assigned
- **Manager Alerts**: Daily email digest with automation stats (emails processed, classification accuracy, routing distribution)
- **Error Alerts**: Slack message to ops channel if Lambda function fails or API errors exceed threshold

## Technical Architecture

### Technology Stack

- **Email Ingestion**: AWS SES (receives emails) → SNS (pub/sub) → Lambda (processing)
- **Backend**: Python 3.11 on AWS Lambda (serverless)
- **Database**: DynamoDB for metadata cache (categorization results, customer lookups)
- **CRM Integration**: HubSpot API for customer tier lookup
- **Linear Integration**: Linear GraphQL API for ticket creation
- **AI**: Claude API (Anthropic) for categorization
- **Email Outbound**: SendGrid API for confirmations
- **File Storage**: S3 for email attachments
- **Monitoring**: CloudWatch for logs, Sentry for errors

### Data Model

**DynamoDB Tables**:

**email_metadata** (cache, TTL 30 days):
- email_id (hash key)
- from_email, subject, body_preview, processed_at, linear_ticket_id

**categorization_cache** (reduce API costs, TTL 7 days):
- subject_hash (hash key)
- product_area, confidence_score, cached_at

**routing_config** (editable by manager):
- config_version (hash key, always "latest")
- product_area_assignments (JSON: {product_area: [team_member_ids]})
- keyword_priority_rules (JSON: {keywords: [priority_level]})

**Linear Data** (not stored by us, managed by Linear):
- Tickets with all metadata
- Comments (including email replies)
- Assignments and status

### AI/Automation Components

**Email Categorization**
- **Purpose**: Determine product area from email content
- **Model**: Claude 3.5 Sonnet via Anthropic API
- **Input**: Email subject + first 1000 chars of body
- **Output**: Product area (Mobile App/Web App/API/Billing/Account) + confidence score (0-100%)
- **Prompt**: "Classify this support email into one of: Mobile App, Web App, API, Billing, Account. Respond with JSON: {product_area: string, confidence: number}"
- **Threshold**: >85% auto-apply, 60-85% flag for review, <60% default to "General"
- **Fallback**: If API error, default to "General" and alert manager
- **Cost**: ~$0.01 per email, ~300 emails/day = $3/day = $90/month (acceptable)

**Smart Routing Algorithm** (no AI, rule-based):
1. Get list of team members assigned to product area (from routing_config)
2. Filter out members with status "Out of Office"
3. Query Linear for each member's open ticket count
4. Assign to member with fewest open tickets
5. If tie, round-robin based on last assignment time

## Edge Cases & Error Handling

**Scenario 1: Email from unknown sender (not in CRM)**
- **Handling**: Assume "Free" tier, proceed with ticket creation. Log for CRM cleanup.

**Scenario 2: Claude API timeout or error during categorization**
- **Handling**: Retry once after 3 seconds. If still fails, default to "General" product area, assign to manager, send Slack alert.

**Scenario 3: Duplicate email (customer sends same request multiple times within 10 minutes)**
- **Handling**: Check DynamoDB for recent emails from same sender with identical subject. If found within 10 min, don't create new ticket. Reply: "We already received your request (Ticket #123)."

**Scenario 4: Linear API failure (can't create ticket)**
- **Handling**: Retry with exponential backoff (3 attempts). If all fail, save to DynamoDB "failed_tickets" table for manual processing, send Slack alert to ops.

**Scenario 5: Email has large attachments (>25MB total)**
- **Handling**: Accept first 25MB of attachments, discard rest. Send email to customer: "We received your request but some attachments were too large. Please reply with smaller files or use [file sharing link]."

**Scenario 6: Customer replies to confirmation before ticket is worked**
- **Handling**: Parse reply, add as comment to ticket in Linear. Don't create duplicate ticket. Support team sees reply in ticket thread.

**Scenario 7: Email is spam or phishing**
- **Handling**: AWS SES has built-in spam filtering. If spam detected, don't process. Log for monitoring. No ticket created, no confirmation sent.

## Security & Privacy Considerations

**Data Sensitivity**
- Customer emails contain PII (name, email, potentially account details)
- Attachments may contain sensitive info (screenshots with data)

**Access Control**
- Lambda functions use IAM roles (principle of least privilege)
- Linear API key stored in AWS Secrets Manager, rotated quarterly
- Only support team has access to Linear tickets
- DynamoDB tables encrypted at rest

**Data Protection**
- All API calls use TLS 1.3
- Email attachments stored in S3 with server-side encryption
- DynamoDB encryption enabled
- No email content logged to CloudWatch (only metadata)

**Compliance**
- **GDPR**: Customer can request deletion via privacy@company.com. Delete from DynamoDB, S3, and Linear.
- **Data Retention**: Emails cached in DynamoDB for 30 days then auto-deleted. Linear tickets retained per company policy (2 years).

**Audit Trail**
- All ticket creations logged in CloudWatch with metadata
- Manager actions (routing rule changes) logged to audit DynamoDB table

## Success Metrics

### Primary Metric

**Ticket Creation Accuracy**: % of tickets auto-created without needing manual recategorization or reassignment.
- **Target**: >85% (allow 15% for edge cases or ambiguous emails)
- **Measurement**: Track tickets with `needs-review` tag or manually recategorized. Query Linear API weekly.

### Secondary Metrics

- **Time to Ticket Creation**: How fast email becomes Linear ticket. Target: <2 minutes (currently ~30 min for manual entry)
- **Customer Confirmation Speed**: Time from email received to confirmation sent. Target: <1 minute
- **Classification Confidence**: Average confidence score from AI. Target: >80%
- **Routing Balance**: Std deviation of open tickets across team members. Target: <3 (even distribution)

### Failure Indicators

- **Low accuracy**: <70% correct categorization → AI prompts need refinement or more training examples
- **Slow processing**: >5 minutes email-to-ticket → Lambda timeout issues or API latency
- **Uneven routing**: One team member gets >50% of tickets → Routing algorithm needs fix
- **High error rate**: >5% of emails fail to process → Infrastructure instability, need investigation

## Implementation Notes

### Phase 1: Email Ingestion & Ticket Creation (Target: 3 weeks)

- AWS SES + Lambda setup for email parsing
- Linear API integration for ticket creation
- Basic categorization (keyword matching, no AI)
- Customer confirmation emails (SendGrid)
- DynamoDB for caching

### Phase 2: AI Categorization (Target: +1 week)

- Claude API integration
- Confidence thresholding
- Categorization cache

### Phase 3: Smart Routing (Target: +1 week)

- Workload-based routing algorithm
- Routing configuration (DynamoDB)
- Manager dashboard for rule editing

### Phase 4: Reply Handling & Polish (Target: +2 weeks)

- Parse customer replies, update tickets
- Duplicate detection
- Error alerting (Slack)
- Monitoring dashboard

### Dependencies

- AWS account with SES, Lambda, DynamoDB, S3 access
- Linear account and API key with ticket creation permissions
- Anthropic API key for Claude access
- SendGrid account for outbound email
- HubSpot API access for CRM lookups
- Slack webhook for alerts
- support@company.com email address configured to forward to SES

## Open Questions

None - ready to implement.

## Interview Context

This specification was developed through a structured interview on 2026-01-13.

Key decisions made during interview:
- Chose AWS Lambda (serverless) over dedicated server to handle variable email volume without overprovisioning
- Decided to use Linear API instead of building custom ticket DB (leverage existing tool, avoid duplication)
- Selected Claude for categorization based on accuracy with complex product questions
- Opted for smart routing by workload instead of round-robin to prevent overload
- Decided against sentiment analysis for v1 (CSAT handled separately, reduces complexity)
